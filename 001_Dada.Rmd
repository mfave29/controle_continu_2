---
title: "000_dada2"
output: 
  github_document:
    toc: true
    toc_depth: 2
---

# Importation des données

```{bash}
wget https://pagesperso.univ-brest.fr/~maignien/teaching/M1-MFA/UE-Ecogenomique2/EcoG2_data_cc2.tar.gz
tar xvzf EcoG2_data_cc2.tar.gz
```

```{r}
path <- "~/controle_continu_2/Stratif_CC2"
list.files(path)
```

# Forward and Reverse
```{r}
fnFs <- sort(list.files(path, pattern="_R1.fastq", full.names = TRUE))
fnRs <- sort(list.files(path, pattern="_R2.fastq", full.names = TRUE))

sample.names <- sapply(strsplit(basename(fnFs), "_"), `[`,1)
```



# Profils de score de qualité 
```{r}
plotQualityProfile(fnFs[1:2])
```

Ici sont présentés les profiles des scores de qualité des forwards de deux échantillons différents. Le score de qualité moyen correspond à la ligne verte. La ligne orange correspond aux quartiles de la distribution du score de qualité.  
Les premières lectures sont de bonne qualité. Plus on fait de lectures, moins la qualité est bonne. C'est pour cela qu'on filtrera plus tard. 

Nous faisons la même chose pour les mêmes échantillons, cette fois-ci avec les reverse : 

```{r}
plotQualityProfile(fnRs[1:2])
```

Nous pouvons constater que les read reverse sont de moins bonne qualité, ce qui apparaît souvent avec Illumina. Nous allons également découper. 


#Filtrage et coupures
Tout d'abord, nous attribuons des noms aux fichiers filtrés. Ainsi, les forward filtrés sont sauvegardés sous le nom de filtFs et les reverse filtrés sous le nom de filtRs.

```{r}
filtFs <- file.path(path, "filtered", paste0(sample.names, "_F_filt.fastq.gz"))
filtRs <- file.path(path, "filtered", paste0(sample.names, "_R_filt.fastq.gz"))
names(filtFs) <- sample.names
names(filtRs) <- sample.names
```

```{r}
library(BiocManager)
```



```{r}
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,190), trimLeft=c(21,21), maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE, compress=TRUE, multithread = TRUE)
head(out)
```



